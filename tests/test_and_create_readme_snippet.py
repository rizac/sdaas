"""
Tests the Python snippets provided in the README to assure that they work and, if any
output is generated, adds it below the snippet (with a tag marking the code block
as auto generated. Each time this test is run, the auto generated
code is recognized by its tag and deleted before re-executing the snippets)

Created on 28 Sep 2020

@author: Riccardo Z. <rizac@gfz-potsdam.de>
"""
import os
import re
import sys
import unittest
from io import StringIO
from os.path import join, dirname, relpath, abspath, basename

from obspy.core.stream import read
from obspy.core.inventory.inventory import read_inventory


class Test(unittest.TestCase):

    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_readme(self):
        """test the README code snippets and updates the README content
        with the snippet code text"""
        # locals_ = Test.create_locals()

        # ret = create_readme_snippet().strip()
        readmefile = join(dirname(dirname(__file__)), 'README.md')
        with open(readmefile) as fle:
            content = fle.read()

        content2 = '\n'.join(create_readme_snippet(content))

        with open(readmefile, 'w') as fle:
            content = fle.write(content2)

        print(f'\nWARNING: {basename(readmefile)} HAS BEEN MODIFIED \n'
              f'WITH THE AUTO-GENERATED CODE SNIPPET IN {basename(__file__)}\n'
              'YOU WILL NEED TO COMMIT THE CHANGES\n')


def create_readme_snippet(readmefile_content):
    """Creates the code snippets in the readme, evaluating them
    so that errors are visible and fixable. To add a new snippet, see module
    docstring above and then copy/paste/modify any of the code blocks below
    """
    _ = len(readmefile_content)
    # remove autogenerated output code:
    TAG = "<!-- THE CODE BLOCK BELOW IS THE OUTPUT OF THE PREVIOUS BLOCK " \
          "AND IT IS AUTOGENERATED WHEN RUNNING TESTS -->"
    readmefile_content = re.sub(r'%s\s+```.*?```' % re.escape(TAG), "",
                                readmefile_content, flags=re.DOTALL | re.MULTILINE)

    assert len(readmefile_content) < _

    locals_ = {}  # create_snippet_locals()
    last_end = 0
    for matcher in re.finditer(r'\s+```python\s(.*?)```', readmefile_content,
                               re.DOTALL | re.MULTILINE):
        if matcher.start() > last_end:
            out = readmefile_content[last_end:matcher.start()].strip()
            if out:
                yield out

        last_end = matcher.end()

        yield ""
        yield matcher.group().strip()

        #  execute snippet code
        code = matcher.group(1).strip()
        output = exec_snippet(code, locals_)

        if output:
            yield TAG
            yield "```\n%s\n```" % (str(output).strip())

        yield ""

    if last_end < len(readmefile_content):
        out = readmefile_content[last_end:].strip()
        if out:
            yield readmefile_content[last_end:].strip()


def exec_snippet(code, locals_):
    tmp = sys.stdout
    buffer = StringIO()
    sys.stdout = buffer
    cwd = os.getcwd()
    os.chdir(dirname(dirname(__file__)))
    try:
        exec(code, globals(), locals_)
        return buffer.getvalue()
    except Exception as err:
        raise ValueError('Check README.md Python snippet, code error fond: %s, %s' %
                         (str(err.__class__.__name__), str(err))) from None
    finally:
        # Restore the original stdout!
        sys.stdout = tmp
        # restore cwd:
        os.chdir(cwd)



if __name__ == "__main__":
    #  import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
