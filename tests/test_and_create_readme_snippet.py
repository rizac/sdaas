"""
Tests the snippets provided in the README to assure that they work

**IMPORTANT**

The tested code snippets here are AUTOMATICALLY inserted in the README.md
file. A COMMIT MIGHT BE NECESSARY AFTER RUNNING THIS FILE DURING TESTS.

The README file can be edited normally without problem. The only place to
keep synchronized with this module are the snippet codes in the
"As Library in your code" section.

To add a new snippet in README.md in the section "As library in your code"
==========================================================================

Insert in the README section the following 3 lines of text,
denoting an "empty snippet":

<!-- THE CODE SNIPPET BELOW IS AUTOGENERATED WHEN RUNNING TESTS. SEE tests/test_and_create_readme_snippet.py -->
```
```

(first line is the marker signaling a snippet, 2nd and 3rd
line are the snippet start and end markers, respectively)

Then, count the index of the newly added empty snippet in the section. Suppose
it's the third, then go to :func:`create_readme_snippet`: therein, there are
several blocks of codes, one block per snippet: the blocks are almost equal
because they perform almost the same operation, the only different part is
their code string that will be evaluated and rendered as snippet. Copy one of
those blocks, paste it before the third one, and edit its code string only.

Run tests and check the README.md


Created on 28 Sep 2020

@author: Riccardo Z. <rizac@gfz-potsdam.de>
"""
import os
import re
import sys
import unittest
from io import StringIO
from os.path import join, dirname, relpath, abspath, basename

from obspy.core.stream import read
from obspy.core.inventory.inventory import read_inventory


class Test(unittest.TestCase):

    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_readme(self):
        """test the README code snippets and updates the README content
        with the snippet code text"""
        # locals_ = Test.create_locals()

        # ret = create_readme_snippet().strip()
        readmefile = join(dirname(dirname(__file__)), 'README.md')
        with open(readmefile) as fle:
            content = fle.read()

        content2 = '\n'.join(create_readme_snippet(content))

        with open(readmefile, 'w') as fle:
            content = fle.write(content2)

        print(f'\nWARNING: {basename(readmefile)} HAS BEEN MODIFIED \n'
              f'WITH THE AUTO-GENERATED CODE SNIPPET IN {basename(__file__)}\n'
              'YOU WILL NEED TO COMMIT THE CHANGES\n')


def create_readme_snippet(readmefile_content):
    """Creates the code snippets in the readme, evaluating them
    so that errors are visible and fixable. To add a new snippet, see module
    docstring above and then copy/paste/modify any of the code blocks below
    """
    _ = len(readmefile_content)
    # remove autogenerated output code:
    TAG = "<!-- THE CODE BLOCK BELOW IS THE OUTPUT OF THE PREVIOUS BLOCK " \
          "AND IT IS AUTOGENERATED WHEN RUNNING TESTS -->"
    readmefile_content = re.sub(r'%s\s+```.*?```' % re.escape(TAG), "",
                                readmefile_content, flags=re.DOTALL | re.MULTILINE)

    assert len(readmefile_content) < _

    locals_ = {}  # create_snippet_locals()
    last_end = 0
    for matcher in re.finditer(r'\s+```python\s(.*?)```', readmefile_content,
                               re.DOTALL | re.MULTILINE):
        if matcher.start() > last_end:
            out = readmefile_content[last_end:matcher.start()].strip()
            if out:
                yield out

        last_end = matcher.end()

        yield ""
        yield matcher.group().strip()

        #  execute snippet code
        code = matcher.group(1).strip()
        output = exec_snippet(code, locals_)

        if output:
            yield TAG
            yield "```\n%s\n```" % (str(output).strip())

    if last_end < len(readmefile_content):
        out = readmefile_content[last_end:].strip()
        if out:
            yield readmefile_content[last_end:].strip()


def exec_snippet(code, locals_):
    tmp = sys.stdout
    buffer = StringIO()
    sys.stdout = buffer
    cwd = os.getcwd()
    os.chdir(dirname(dirname(__file__)))
    try:
        exec(code, globals(), locals_)
        return buffer.getvalue()
    except Exception as err:
        asd= 9
        raise
    finally:
        # Restore the original stdout!
        sys.stdout = tmp
        # restore cwd:
        os.chdir(cwd)


#     if last_end < len(readmefile_content):
#         yield readmefile_content[last_end:]
#
#     end = 0
#
#     # single code snippet code. You can copy paste modify the following block
#     # to create a new snippet in the README:
#     start, end = get_code_snippet_bounds(readmefile_content, end)
#     code = '''from sdaas.core import traces_scores
# traces_scores(stream, inventory)'''
#     code_snippet = make_snippet(code, loc)
#     readmefile_content = readmefile_content[:start] + \
#                          code_snippet + readmefile_content[end:]
#
#
#     start, end = get_code_snippet_bounds(readmefile_content, end)
#     code = '''from sdaas.core import traces_idscores
# traces_idscores(stream, inventory)'''
#     code_snippet = make_snippet(code, loc)
#     readmefile_content = readmefile_content[:start] + \
#                          code_snippet + readmefile_content[end:]
#
#     start, end = get_code_snippet_bounds(readmefile_content, end)
#     code = '''from sdaas.core import traces_idscores
# traces_idscores(stream, inventory, idfunc=lambda t: t.get_id())'''
#     code_snippet = make_snippet(code, loc)
#     readmefile_content = readmefile_content[:start] + \
#                          code_snippet + readmefile_content[end:]
#
#     start, end = get_code_snippet_bounds(readmefile_content, end)
#     code = '''from sdaas.core import streams_scores
# from sdaas.core import streams_idscores'''
#     code_snippet = wrap_in_code_snippet(code)
#     readmefile_content = readmefile_content[:start] + \
#                          code_snippet + readmefile_content[end:]
#
#     start, end = get_code_snippet_bounds(readmefile_content, end)
#     code = '''from sdaas.core import trace_score'''
#     code_snippet = wrap_in_code_snippet(code)
#     readmefile_content = readmefile_content[:start] + \
#                          code_snippet + readmefile_content[end:]
#
#     loc['streams'] = [loc['stream']] * 5
#
#     start, end = get_code_snippet_bounds(readmefile_content, end)
#     code = '''from sdaas.core import streams_scores
# streams_scores(streams, inventory)'''
#     code_snippet = make_snippet(code, loc)
#     readmefile_content = readmefile_content[:start] + \
#                          code_snippet + readmefile_content[end:]
#
#     start, end = get_code_snippet_bounds(readmefile_content, end)
#     code = '''from sdaas.core import trace_features, aa_scores
# feats = []
# for stream in streams:
#     for trace in stream:
#         feats.append(trace_features(trace, inventory))
# aa_scores(feats)'''
#     code_snippet = make_snippet(code, loc)
#     readmefile_content = readmefile_content[:start] + \
#                          code_snippet + readmefile_content[end:]
#
#     return readmefile_content
#
#

# def create_snippet_locals():
#     """Create a dict of local variables to be apssed to make_snippet"""
#     dataroot = join(dirname(__file__), 'data')
#     stream = read(join(dataroot, 'GE.FLT1..HH?.mseed'))
#     inventory = read_inventory(join(dataroot, 'GE.FLT1.xml'))
#
#     stream2 = read(join(dataroot, 'trace_GE.APE.mseed'))
#     inventory2 = read_inventory(join(dataroot, 'inventory_GE.APE.xml'))
#
#     streams = [stream2, stream]
#
#     return locals()

#
#
# def get_code_snippet_bounds(readme_content, start_index):
#     """Return the next code snippet bounds (including leading and trailing
#     ```)"""
#     tag1 = "<!-- THE CODE SNIPPET BELOW IS AUTOGENERATED WHEN RUNNING TESTS. "
#     idx1 = readme_content.index(tag1, start_index)
#     tag2 = "```"
#     idx2 = readme_content.index(tag2, idx1)
#     idx3 = readme_content.index(tag2, idx2+len(tag2))
#     return idx2, idx3 + len(tag2)
#
#
# def make_snippet(code, locals_):
#     code_lines = code.strip().split('\n')
#     code_str = '\n'.join(f'>>> {_}' for _ in code_lines)
#     # to evaluate last line, create a dummy var:
#     code = "\n".join(code_lines[:-1]) + '\n__var__= (' + code_lines[-1] + ")"
#     exec(code, globals(), locals_)
#     result = repr(locals_['__var__'])
#     return wrap_in_code_snippet(code_str, result)
#
#
# def wrap_in_code_snippet(code_text, code_output_text=None):
#     ret = f"```python\n{code_text.strip()}\n"
#     if code_output_text:
#        ret += f"{code_output_text.strip()}\n"
#     return ret + "```\n\n"


if __name__ == "__main__":
    #  import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
