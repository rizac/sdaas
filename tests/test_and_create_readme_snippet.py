"""
Tests the snippets providede in the README to assure that they work. Also,
MODIFIES the README SO A COMMIT MIGHT BE NECESSARY AFTER THIS RUN (a message
is printed in case, if no message is shown, then the readme was not changed)

Created on 28 Sep 2020

@author: Riccardo Z. <rizac@gfz-potsdam.de>
"""
import unittest
from os.path import join, dirname, relpath, abspath, basename

from obspy.core.stream import read
from obspy.core.inventory.inventory import read_inventory


class Test(unittest.TestCase):

    def setUp(self):
        pass

    def tearDown(self):
        pass

    # @staticmethod
    # def create_locals(self):
    #     dataroot = join(dirname(__file__), 'data')
    #     stream = read(join(dataroot, 'GE.FLT1..HH?.mseed'))
    #     inventory = read_inventory(join(dataroot, 'GE.FLT1.xml'))
    #
    #     stream2 = read(join(dataroot, 'trace_GE.APE.mseed'))
    #     inventory2 = read_inventory(join(dataroot, 'inventory_GE.APE.xml'))
    #
    #     streams = [stream2, stream]
    #
    #     return locals()

    def test_readme(self):
        """tests the readme"""
        # locals_ = Test.create_locals()

        # ret = create_readme_snippet().strip()
        readmefile = join(dirname(dirname(__file__)), 'README.md')
        with open(readmefile) as fle:
            content = fle.read()

        content2 = create_readme_snippet(content)

        with open(readmefile, 'w') as fle:
            content = fle.write(content2)

        print(f'\nWARNING: {basename(readmefile)} HAS BEEN MODIFIED \n'
              f'WITH THE AUTO-GENERATED CODE SNIPPET IN {basename(__file__)}\n'
              'YOU WILL NEED TO COMMIT THE CHANGES\n')


def create_readme_snippet(readmefile_content):

    loc = create_snippet_locals()

    end = 0
    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import traces_scores
traces_scores(stream, inventory)'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]


    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import traces_idscores
traces_idscores(stream, inventory)'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import traces_idscores
traces_idscores(stream, inventory, idfunc=lambda t: t.get_id())'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import streams_scores
from sdaas.core import streams_idscores'''
    code_snippet = wrap_in_code_snippet(code)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import trace_score'''
    code_snippet = wrap_in_code_snippet(code)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    loc['streams'] = [loc['stream']] * 5

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import streams_scores
streams_scores(streams, inventory)'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import trace_features, aa_scores
feats = []
for stream in streams:
    for trace in stream:
        feats.append(trace_features(trace, inventory))
aa_scores(feats)'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    return readmefile_content


def create_snippet_locals():
    """Creates a dict of local variables to be apssed to make_snippet"""
    dataroot = join(dirname(__file__), 'data')
    stream = read(join(dataroot, 'GE.FLT1..HH?.mseed'))
    inventory = read_inventory(join(dataroot, 'GE.FLT1.xml'))

    stream2 = read(join(dataroot, 'trace_GE.APE.mseed'))
    inventory2 = read_inventory(join(dataroot, 'inventory_GE.APE.xml'))

    streams = [stream2, stream]

    return locals()


def get_code_snippet_bounds(readme_content, start_index):
    """Return the next code snippet bounds (including leading and trailing
    ```)"""
    tag1 = "<!-- THE CODE SNIPPET BELOW IS AUTOGENERATED WHEN RUNNING TESTS. "
    idx1 = readme_content.index(tag1, start_index)
    tag2 = "```"
    idx2 = readme_content.index(tag2, idx1)
    idx3 = readme_content.index(tag2, idx2+len(tag2))
    return idx2, idx3 + len(tag2)


def make_snippet(code, locals_):
    code_lines = code.strip().split('\n')
    code_str = '\n'.join(f'>>> {_}' for _ in code_lines)
    # to evaluate last line, create a dummy var:
    code = "\n".join(code_lines[:-1]) + '\n__var__= (' + code_lines[-1] + ")"
    exec(code, globals(), locals_)
    result = repr(locals_['__var__'])
    return wrap_in_code_snippet(code_str, result)


def wrap_in_code_snippet(code_text, code_output_text=None):
    ret = f"```python\n{code_text.strip()}\n"
    if code_output_text:
       ret += f"{code_output_text.strip()}\n"
    return ret + "```\n\n"

# def makesnippet(title, code, locals_, eval_last_line=True):
#     code_lines = code.strip().split('\n')
#     if eval_last_line:
#         code = "\n".join(code_lines[:-1]) + '\n__var__= (' + code_lines[-1] + ")"
#     exec(code, globals(), locals_)
#     code_str = '\n'.join(f'>>> {_}' for _ in code_lines)
#     result = repr(locals_['__var__']) + '\n' if eval_last_line else ''
#     return f'''{title.strip()}
# ```python
# {code_str}
# {result}```
#
# '''


if __name__ == "__main__":
    #  import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
