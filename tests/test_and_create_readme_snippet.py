"""
Tests the snippets provide in the README to assure that they work, so that in
case of code changes the doc is also hopefully quickly updated.

To automatize things, THIS TEST, WHEN RUN, ALSO MODIFIES the README SO A COMMIT
MIGHT BE NECESSARY  AFTER THIS RUN

To add a new snippet in README.md
=================================

Write your text normally within the "As Library in your code". Whenever you
want to add a new snippet, insert following "empty snippet":

<!-- THE CODE SNIPPET BELOW IS AUTOGENERATED WHEN RUNNING TESTS. SEE tests/test_and_create_readme_snippet.py -->
```
```

(first line is the marker making the code recognizing a snippet, 2nd and 3rd
line are the snippet start and end markers, respectively. See code below for details)

Count the index of the newly added empty snippet in the README, and add the
corrsesponding code in the same index in :func:`create_readme_snippet`


Created on 28 Sep 2020

@author: Riccardo Z. <rizac@gfz-potsdam.de>
"""
import unittest
from os.path import join, dirname, relpath, abspath, basename

from obspy.core.stream import read
from obspy.core.inventory.inventory import read_inventory


class Test(unittest.TestCase):

    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_readme(self):
        """test the README code snippets and updates the README content
        with the snippet code text"""
        # locals_ = Test.create_locals()

        # ret = create_readme_snippet().strip()
        readmefile = join(dirname(dirname(__file__)), 'README.md')
        with open(readmefile) as fle:
            content = fle.read()

        content2 = create_readme_snippet(content)

        with open(readmefile, 'w') as fle:
            content = fle.write(content2)

        print(f'\nWARNING: {basename(readmefile)} HAS BEEN MODIFIED \n'
              f'WITH THE AUTO-GENERATED CODE SNIPPET IN {basename(__file__)}\n'
              'YOU WILL NEED TO COMMIT THE CHANGES\n')


def create_readme_snippet(readmefile_content):
    """Creates the code snippets in the readme, evaluating them
    so that errors are visible and fixable. To add a new snippet, see module
    docstring above and then copy/paste/modify any of the code blocks below
    """

    loc = create_snippet_locals()

    end = 0

    # single code snippet code. You can copy paste modify the following block
    # to create a new snippet in the README:
    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import traces_scores
traces_scores(stream, inventory)'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]


    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import traces_idscores
traces_idscores(stream, inventory)'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import traces_idscores
traces_idscores(stream, inventory, idfunc=lambda t: t.get_id())'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import streams_scores
from sdaas.core import streams_idscores'''
    code_snippet = wrap_in_code_snippet(code)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import trace_score'''
    code_snippet = wrap_in_code_snippet(code)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    loc['streams'] = [loc['stream']] * 5

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import streams_scores
streams_scores(streams, inventory)'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    start, end = get_code_snippet_bounds(readmefile_content, end)
    code = '''from sdaas.core import trace_features, aa_scores
feats = []
for stream in streams:
    for trace in stream:
        feats.append(trace_features(trace, inventory))
aa_scores(feats)'''
    code_snippet = make_snippet(code, loc)
    readmefile_content = readmefile_content[:start] + \
                         code_snippet + readmefile_content[end:]

    return readmefile_content


def create_snippet_locals():
    """Create a dict of local variables to be apssed to make_snippet"""
    dataroot = join(dirname(__file__), 'data')
    stream = read(join(dataroot, 'GE.FLT1..HH?.mseed'))
    inventory = read_inventory(join(dataroot, 'GE.FLT1.xml'))

    stream2 = read(join(dataroot, 'trace_GE.APE.mseed'))
    inventory2 = read_inventory(join(dataroot, 'inventory_GE.APE.xml'))

    streams = [stream2, stream]

    return locals()


def get_code_snippet_bounds(readme_content, start_index):
    """Return the next code snippet bounds (including leading and trailing
    ```)"""
    tag1 = "<!-- THE CODE SNIPPET BELOW IS AUTOGENERATED WHEN RUNNING TESTS. "
    idx1 = readme_content.index(tag1, start_index)
    tag2 = "```"
    idx2 = readme_content.index(tag2, idx1)
    idx3 = readme_content.index(tag2, idx2+len(tag2))
    return idx2, idx3 + len(tag2)


def make_snippet(code, locals_):
    code_lines = code.strip().split('\n')
    code_str = '\n'.join(f'>>> {_}' for _ in code_lines)
    # to evaluate last line, create a dummy var:
    code = "\n".join(code_lines[:-1]) + '\n__var__= (' + code_lines[-1] + ")"
    exec(code, globals(), locals_)
    result = repr(locals_['__var__'])
    return wrap_in_code_snippet(code_str, result)


def wrap_in_code_snippet(code_text, code_output_text=None):
    ret = f"```python\n{code_text.strip()}\n"
    if code_output_text:
       ret += f"{code_output_text.strip()}\n"
    return ret + "```\n\n"


if __name__ == "__main__":
    #  import sys;sys.argv = ['', 'Test.testName']
    unittest.main()
